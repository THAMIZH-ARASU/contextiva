# Story 3.4: MCP Server Implementation - Complete TODO List

## Executive Summary

This document provides a comprehensive, step-by-step TODO list for implementing a complete MCP (Model Context Protocol) server for the Contextiva knowledge engine using FastMCP framework.

**Framework**: FastMCP 2.0 (https://gofastmcp.com)
**Integration Level**: Deep - Reuses all Application layer services
**Authentication**: JWT (same as REST API)
**Timeline Estimate**: 12-16 hours for complete implementation + testing

---

## Phase 1: Environment Setup & Dependencies (2 hours)

### 1.1 Research & Install FastMCP Framework
- [ ] Read FastMCP documentation (https://gofastmcp.com/getting-started/welcome)
- [ ] Understand FastMCP decorators: `@mcp.tool`, `@mcp.resource`, `@mcp.prompt`
- [ ] Review authentication patterns for MCP servers
- [ ] Add `fastmcp` to `pyproject.toml` dependencies
  ```toml
  fastmcp = "^2.0.0"  # Check latest version
  ```
- [ ] Run `poetry lock` to update lock file
- [ ] Run `poetry install` to install dependencies
- [ ] Verify FastMCP installation: `python -c "import fastmcp; print(fastmcp.__version__)"`

### 1.2 Document MCP Architecture Decisions
- [ ] Update `docs/architecture/tech-stack.md` with FastMCP version
- [ ] Document MCP server architecture in `docs/architecture/components.md`
- [ ] Add MCP security considerations to `docs/architecture/security.md`
- [ ] Update README.md with MCP server information

---

## Phase 2: MCP Server Foundation (3-4 hours)

### 2.1 Create MCP Directory Structure
- [ ] Create `src/mcp/__init__.py`
- [ ] Create `src/mcp/server.py` (main MCP server)
- [ ] Create `src/mcp/context.py` (dependency injection)
- [ ] Create `src/mcp/tools/__init__.py`
- [ ] Create `src/mcp/tools/projects.py`
- [ ] Create `src/mcp/tools/documents.py`
- [ ] Create `src/mcp/tools/tasks.py` (future)
- [ ] Create `src/mcp/tools/rag.py`
- [ ] Create `src/mcp/auth.py` (JWT middleware)
- [ ] Verify all files follow snake_case naming convention

### 2.2 Implement MCP Server Core (`src/mcp/server.py`)
- [ ] Import FastMCP: `from fastmcp import FastMCP, Context`
- [ ] Create FastMCP instance with server name
  ```python
  mcp = FastMCP(
      name="Contextiva Knowledge Engine",
      dependencies=[...],  # DB, Redis, etc.
      on_duplicate_tools="error",
      mask_error_details=True  # Security
  )
  ```
- [ ] Load settings from `src/shared/config/settings.py`
- [ ] Implement server lifecycle methods (startup, shutdown)
- [ ] Add comprehensive logging using structured logger
- [ ] Create server entry point with `if __name__ == "__main__": mcp.run()`
- [ ] Add docstrings following coding standards

### 2.3 Implement Dependency Injection (`src/mcp/context.py`)
- [ ] Create async context manager for database connection pool
- [ ] Create async context manager for Redis client
- [ ] Initialize LLM provider factory
- [ ] Inject Application layer services:
  - [ ] ProjectService
  - [ ] DocumentService  
  - [ ] KnowledgeService
  - [ ] RAGService (from Stories 3.1-3.3)
- [ ] Implement repository instances (ProjectRepository, DocumentRepository, etc.)
- [ ] Follow dependency injection pattern (no singletons)
- [ ] Add cleanup logic in context manager `__aexit__`

### 2.4 Implement JWT Authentication (`src/mcp/auth.py`)
- [ ] Reuse JWT validation logic from `src/shared/utils/security.py` (Story 1.4)
- [ ] Create `validate_mcp_token()` async function
- [ ] Extract token from MCP request headers or context
- [ ] Implement `get_current_user_from_token()` helper
- [ ] Return User model or raise UnauthorizedAccessError
- [ ] Add comprehensive error messages (without exposing secrets)
- [ ] Implement RBAC helper: `check_permission(user, resource, action)`
- [ ] NEVER log tokens or sensitive data

---

## Phase 3: MCP Tools Implementation (4-5 hours)

### 3.1 Project Management Tools (`src/mcp/tools/projects.py`)

#### Tool: create_project
- [ ] Define tool with `@mcp.tool` decorator
- [ ] Parameters:
  - [ ] `name: str` (required, 1-100 chars)
  - [ ] `description: str | None` (optional, max 500 chars)
  - [ ] `tags: list[str] | None` (optional)
  - [ ] `ctx: Context` (for authentication)
- [ ] Validate parameters using Pydantic Field constraints
- [ ] Extract and validate JWT token from context
- [ ] Call `ProjectService.create_project()` from Application layer
- [ ] Return structured output with project_id, name, created_at
- [ ] Handle errors: ProjectAlreadyExistsError, ValidationError, UnauthorizedAccessError
- [ ] Add comprehensive docstring describing tool purpose and parameters
- [ ] Add type hints for all parameters and return value

#### Tool: list_projects
- [ ] Define tool with `@mcp.tool` decorator
- [ ] Parameters:
  - [ ] `ctx: Context` (for authentication)
- [ ] Validate JWT token
- [ ] Call `ProjectService.list_projects(user_id)` from Application layer
- [ ] Return list of projects with structured output schema
- [ ] Handle pagination if needed (optional: add limit/offset params)
- [ ] Add error handling

#### Tool: get_project
- [ ] Define tool with `@mcp.tool` decorator
- [ ] Parameters:
  - [ ] `project_id: str` (UUID string)
  - [ ] `ctx: Context`
- [ ] Validate JWT token and project access
- [ ] Convert project_id string to UUID
- [ ] Call `ProjectService.get_project()` from Application layer
- [ ] Return project details with structured output
- [ ] Handle ProjectNotFoundError, UnauthorizedAccessError

### 3.2 Document Management Tools (`src/mcp/tools/documents.py`)

#### Tool: ingest_document
- [ ] Define tool with `@mcp.tool` decorator
- [ ] Parameters:
  - [ ] `project_id: str` (UUID string, required)
  - [ ] `content: str` (document content as text, required)
  - [ ] `title: str` (document title, required)
  - [ ] `document_type: str` (PDF|TXT|MD|OTHER, required)
  - [ ] `metadata: dict[str, Any] | None` (optional JSON metadata)
  - [ ] `ctx: Context`
- [ ] Validate JWT token and project access
- [ ] Convert project_id to UUID
- [ ] Map document_type string to DocumentType enum
- [ ] Call `KnowledgeService.ingest_document()` from Application layer
- [ ] Return document_id and ingestion status
- [ ] Handle errors: ProjectNotFoundError, ValidationError, IngestionError
- [ ] Add progress reporting using `ctx.report_progress()` if chunking is slow

#### Tool: list_documents
- [ ] Define tool with `@mcp.tool` decorator
- [ ] Parameters:
  - [ ] `project_id: str` (UUID string, required)
  - [ ] `ctx: Context`
- [ ] Validate JWT token and project access
- [ ] Call `DocumentService.list_documents(project_id)` from Application layer
- [ ] Return list of documents with metadata
- [ ] Add pagination support (limit/offset)

#### Tool: get_document
- [ ] Define tool with `@mcp.tool` decorator
- [ ] Parameters:
  - [ ] `document_id: str` (UUID string, required)
  - [ ] `ctx: Context`
- [ ] Validate JWT token and document access
- [ ] Call `DocumentService.get_document()` from Application layer
- [ ] Return document details
- [ ] Handle DocumentNotFoundError

### 3.3 RAG Query Tools (`src/mcp/tools/rag.py`)

#### Tool: query_knowledge
- [ ] Define tool with `@mcp.tool` decorator
- [ ] Parameters:
  - [ ] `project_id: str` (UUID string, required)
  - [ ] `query_text: str` (search query, required, 1-500 chars)
  - [ ] `top_k: int` (number of results, default=5, range 1-20)
  - [ ] `use_hybrid_search: bool` (default=False) - Story 3.2 feature
  - [ ] `use_re_ranking: bool` (default=False) - Story 3.2 feature
  - [ ] `use_agentic_rag: bool` (default=False) - Story 3.3 feature
  - [ ] `ctx: Context`
- [ ] Validate JWT token and project access
- [ ] Convert project_id to UUID
- [ ] Create RAGQueryRequest schema instance
- [ ] Call `RAGService.query()` from Application layer (or QueryKnowledgeUseCase directly)
- [ ] Return structured output with:
  - [ ] `results: list[dict]` (knowledge items with scores)
  - [ ] `synthesized_answer: str | None` (if agentic RAG enabled)
  - [ ] `query_id: str` (UUID for tracking)
  - [ ] `total_results: int`
- [ ] Handle errors: ProjectNotFoundError, ValidationError, LLMError, CacheError
- [ ] Add logging for RAG queries
- [ ] Add progress reporting if synthesis is slow

### 3.4 Common Tool Patterns
- [ ] All tools MUST extract and validate JWT token from Context
- [ ] All tools MUST check user has access to requested project/document
- [ ] All tools MUST use Application layer services (NO business logic in MCP layer)
- [ ] All tools MUST return structured output with proper JSON schemas
- [ ] All tools MUST have comprehensive docstrings
- [ ] All tools MUST use async/await for I/O operations
- [ ] All tools MUST handle errors gracefully and return user-friendly messages
- [ ] All tools MUST use type hints (Pydantic Field for validation)

---

## Phase 4: MCP Resources (Optional - 1-2 hours)

### 4.1 Project Resources (`src/mcp/resources/projects.py`)

#### Resource: project://{project_id}
- [ ] Define resource template with `@mcp.resource` decorator
- [ ] URI: `project://{project_id}`
- [ ] Return project details as JSON
- [ ] Validate JWT token from Context
- [ ] Call ProjectService.get_project()
- [ ] Set mime_type="application/json"
- [ ] Add resource annotations (readOnlyHint=True, idempotentHint=True)

#### Resource: project://{project_id}/documents
- [ ] URI: `project://{project_id}/documents`
- [ ] Return list of documents as JSON
- [ ] Validate JWT token
- [ ] Call DocumentService.list_documents()

### 4.2 Document Resources (`src/mcp/resources/documents.py`)

#### Resource: document://{document_id}
- [ ] URI: `document://{document_id}`
- [ ] Return document content and metadata
- [ ] Validate JWT token
- [ ] Call DocumentService.get_document()

#### Resource: document://{document_id}/chunks
- [ ] URI: `document://{document_id}/chunks`
- [ ] Return knowledge chunks for document
- [ ] Validate JWT token
- [ ] Call KnowledgeRepository.list_by_document()

### 4.3 Knowledge Resources (`src/mcp/resources/knowledge.py`)

#### Resource: knowledge://{project_id}/search?q={query}
- [ ] URI template with query parameter
- [ ] Return search results as JSON
- [ ] Validate JWT token
- [ ] Call QueryKnowledgeUseCase

---

## Phase 5: Docker Integration (1 hour)

### 5.1 Update docker-compose.yml
- [ ] Add new `mcp` service alongside `api` service
- [ ] Configuration:
  ```yaml
  mcp:
    build: .
    command: poetry run python -m src.mcp.server
    ports:
      - "8001:8001"  # MCP server port
    depends_on:
      - postgres
      - redis
    environment:
      - POSTGRES_HOST=postgres
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_PORT=5432
      - REDIS_URL=redis://redis:6379/0
      - JWT_SECRET_KEY=${JWT_SECRET_KEY}
      - MCP_PORT=8001
    env_file:
      - .env
    volumes:
      - .:/app
    networks:
      - contextiva_default
  ```
- [ ] Update `networks` section if needed
- [ ] Test with `docker-compose up mcp`

### 5.2 Add MCP Configuration to Settings
- [ ] Update `src/shared/config/settings.py`
- [ ] Add MCPSettings class:
  ```python
  class MCPSettings(BaseSettings):
      host: str = "0.0.0.0"
      port: int = 8001
      server_name: str = "Contextiva Knowledge Engine"
      max_concurrent_tools: int = 10
      enable_progress_notifications: bool = True
  ```
- [ ] Add `mcp: MCPSettings = MCPSettings()` to main Settings class
- [ ] Add environment variables to `.env.example`

---

## Phase 6: Testing (3-4 hours)

### 6.1 Unit Tests for MCP Tools (`tests/unit/mcp/tools/`)

#### test_projects.py
- [ ] Test `create_project` with valid parameters
- [ ] Test `create_project` with invalid parameters (missing name, too long, etc.)
- [ ] Test `create_project` with unauthorized user (invalid JWT)
- [ ] Test `create_project` when project already exists
- [ ] Test `list_projects` with valid user
- [ ] Test `list_projects` with no projects
- [ ] Test `get_project` with valid project_id
- [ ] Test `get_project` with invalid project_id (404)
- [ ] Test `get_project` with unauthorized access
- [ ] Mock ProjectService for all tests
- [ ] Mock JWT validation for all tests
- [ ] Follow AAA pattern (Arrange, Act, Assert)
- [ ] Target 90%+ coverage

#### test_documents.py
- [ ] Test `ingest_document` with valid parameters
- [ ] Test `ingest_document` with invalid project_id
- [ ] Test `ingest_document` with unsupported document type
- [ ] Test `ingest_document` with large content (test chunking)
- [ ] Test `ingest_document` with unauthorized access
- [ ] Test `list_documents` with valid project
- [ ] Test `list_documents` with empty project
- [ ] Test `get_document` with valid document_id
- [ ] Test `get_document` with invalid document_id
- [ ] Mock KnowledgeService and DocumentService
- [ ] Mock JWT validation
- [ ] Target 90%+ coverage

#### test_rag.py
- [ ] Test `query_knowledge` with basic query (no flags)
- [ ] Test `query_knowledge` with hybrid_search=True
- [ ] Test `query_knowledge` with re_ranking=True
- [ ] Test `query_knowledge` with agentic_rag=True
- [ ] Test `query_knowledge` with all flags enabled
- [ ] Test `query_knowledge` with invalid project_id
- [ ] Test `query_knowledge` with empty query
- [ ] Test `query_knowledge` with unauthorized access
- [ ] Test `query_knowledge` with cache hit scenario
- [ ] Test `query_knowledge` with LLM failure (graceful degradation)
- [ ] Mock RAGService / QueryKnowledgeUseCase
- [ ] Mock JWT validation
- [ ] Verify structured output schema
- [ ] Target 90%+ coverage

### 6.2 Integration Tests (`tests/integration/mcp/`)

#### test_mcp_server.py
- [ ] Test MCP server initialization
- [ ] Test server connects to PostgreSQL successfully
- [ ] Test server connects to Redis successfully
- [ ] Test Application layer services are injected correctly
- [ ] Test server startup and shutdown lifecycle
- [ ] Test dependency cleanup on shutdown
- [ ] Use Testcontainers for PostgreSQL and Redis
- [ ] Verify all services are properly initialized

#### test_mcp_auth.py
- [ ] Test JWT token extraction from MCP context
- [ ] Test JWT token validation (valid token)
- [ ] Test JWT token validation (expired token)
- [ ] Test JWT token validation (invalid signature)
- [ ] Test JWT token validation (missing token)
- [ ] Test user extraction from token
- [ ] Test RBAC permission checks
- [ ] Use real JWT tokens generated for testing

### 6.3 End-to-End Tests (`tests/e2e/mcp/`)

#### test_mcp_e2e.py
- [ ] Create MCP client using FastMCP Client library:
  ```python
  from fastmcp import Client
  async with Client("http://localhost:8001") as client:
      # Test scenarios
  ```
- [ ] Test E2E: Connect to MCP server with valid JWT
- [ ] Test E2E: Create project via `create_project` tool
- [ ] Test E2E: Ingest document via `ingest_document` tool
- [ ] Test E2E: Query knowledge via `query_knowledge` tool (basic)
- [ ] Test E2E: Query knowledge with hybrid search enabled
- [ ] Test E2E: Query knowledge with re-ranking enabled
- [ ] Test E2E: Query knowledge with agentic RAG enabled (verify synthesized answer)
- [ ] Test E2E: Full workflow (create project → ingest doc → query → verify results)
- [ ] Test E2E: Authentication failure (invalid token)
- [ ] Test E2E: Authorization failure (access other user's project)
- [ ] Test E2E: Invalid parameters (proper error messages)
- [ ] Test E2E: Concurrent tool invocations (test parallelism)
- [ ] All tests create and clean up their own data
- [ ] Run against fully started MCP server (docker-compose up mcp)

### 6.4 Test Execution Commands
- [ ] Create test script for Docker execution:
  ```bash
  # Unit tests
  docker exec contextiva-mcp-1 poetry run pytest tests/unit/mcp/ -v
  
  # Integration tests
  docker exec contextiva-mcp-1 poetry run pytest tests/integration/mcp/ -v
  
  # E2E tests (requires MCP server running)
  docker-compose up -d mcp
  docker exec contextiva-mcp-1 poetry run pytest tests/e2e/mcp/ -v
  ```
- [ ] Add test commands to `test_commands.md`
- [ ] Verify all tests pass in CI/CD pipeline

---

## Phase 7: Documentation & Polish (1-2 hours)

### 7.1 Update README.md
- [ ] Add "MCP Server" section
- [ ] Document how to start MCP server: `docker-compose up mcp`
- [ ] Document MCP server URL: `http://localhost:8001`
- [ ] Add examples of connecting from AI agents
- [ ] Document available MCP tools and their parameters
- [ ] Add troubleshooting section

### 7.2 Create MCP API Documentation
- [ ] Create `docs/mcp/README.md`
- [ ] Document all MCP tools with examples:
  - [ ] create_project example
  - [ ] ingest_document example
  - [ ] query_knowledge example (all flags)
- [ ] Document authentication (JWT token in headers)
- [ ] Document error codes and messages
- [ ] Add code examples in Python (using FastMCP Client)

### 7.3 Update Architecture Documentation
- [ ] Update `docs/architecture/components.md` - add MCP layer
- [ ] Update `docs/architecture/source-tree.md` - add src/mcp/ structure
- [ ] Update `docs/architecture/rest-api-spec.md` - mention MCP as alternative
- [ ] Ensure MCP follows Clean Architecture principles (documented)

### 7.4 Code Quality Checks
- [ ] Run linting: `docker exec contextiva-mcp-1 poetry run ruff check src/mcp/`
- [ ] Run formatting: `docker exec contextiva-mcp-1 poetry run black src/mcp/`
- [ ] Run type checking: `docker exec contextiva-mcp-1 poetry run mypy src/mcp/`
- [ ] Fix all linting/type errors
- [ ] Verify all docstrings are comprehensive
- [ ] Verify all type hints are correct

---

## Phase 8: Story Completion Checklist (30 minutes)

### 8.1 Verify Acceptance Criteria
- [ ] **AC1**: `mcp/server.py` file created implementing MCP specification ✓
- [ ] **AC2**: MCP server configured as service in docker-compose.yml ✓
- [ ] **AC3**: MCP server reuses Application services (ProjectService, RAGService, etc.) ✓
- [ ] **AC4**: MCP tools defined for create_project, ingest_document, query_knowledge ✓
- [ ] **AC5**: MCP server secured with JWT authentication ✓
- [ ] **AC6**: E2E tests created and passing ✓

### 8.2 Run Full Test Suite
- [ ] Unit tests: 100% passing
- [ ] Integration tests: 100% passing
- [ ] E2E tests: 100% passing
- [ ] Linting: No errors
- [ ] Type checking: No errors
- [ ] Test coverage: 85%+ overall

### 8.3 Update Story File
- [ ] Mark all tasks as complete [x]
- [ ] Update "Dev Agent Record" section:
  - [ ] Agent Model Used
  - [ ] Debug Log References
  - [ ] Completion Notes
  - [ ] File List (all created/modified files)
  - [ ] Change Log
- [ ] Set Status to "Ready for Review"
- [ ] Add completion date

### 8.4 Create QA Submission
- [ ] Run comprehensive test report
- [ ] Document test coverage statistics
- [ ] List all created files and LOC
- [ ] Document any deviations from story requirements
- [ ] Submit for QA review

---

## Estimated Timeline Summary

| Phase | Task | Est. Time |
|-------|------|-----------|
| 1 | Environment Setup & Dependencies | 2 hours |
| 2 | MCP Server Foundation | 3-4 hours |
| 3 | MCP Tools Implementation | 4-5 hours |
| 4 | MCP Resources (Optional) | 1-2 hours |
| 5 | Docker Integration | 1 hour |
| 6 | Testing (Unit + Integration + E2E) | 3-4 hours |
| 7 | Documentation & Polish | 1-2 hours |
| 8 | Story Completion Checklist | 0.5 hours |
| **Total** | **Complete Implementation** | **15.5-20.5 hours** |

**Recommended Approach**: Complete Phases 1-3, 5-6 first (core functionality + tests), then add Phase 4 (Resources) if time permits.

---

## Critical Success Factors

1. **Authentication FIRST**: Implement JWT validation before any tool logic
2. **No Business Logic in MCP Layer**: Only orchestration and validation
3. **Comprehensive Error Handling**: Every tool must handle errors gracefully
4. **Test Coverage**: Target 85%+ coverage before marking story complete
5. **Docker-First Development**: All testing via Docker (like Stories 3.1-3.3)
6. **Follow Existing Patterns**: Use same patterns as REST API (from Epic 1)

---

## Additional Enhancements (Future Stories)

### Advanced MCP Features (Optional - Beyond Story 3.4)
- [ ] MCP Prompts: Create reusable prompt templates
- [ ] MCP Sampling: Implement LLM sampling for tool assistance
- [ ] Progress Notifications: Real-time progress for long-running tools
- [ ] Tool Composition: Chain multiple tools together
- [ ] Advanced Resources: Dynamic resource templates with query params
- [ ] WebSocket Support: Real-time updates for knowledge ingestion
- [ ] Rate Limiting: Protect against tool abuse
- [ ] Analytics: Track tool usage and performance

---

**End of TODO List**

This comprehensive TODO list provides a complete roadmap for implementing the MCP server for Contextiva. Follow the phases sequentially, marking items complete as you go, and you'll have a production-ready MCP server integrated with the existing knowledge engine.
