# Story 3.4: MCP Server Integration

## Status

**Draft**

## Story

**As a** an AI Agent (programmatic client),
**I want** to connect to a Model Context Protocol (MCP) server,
**so that** I can natively interact with the Contextiva knowledge engine (FR12).

## Acceptance Criteria

1. An `mcp/server.py` file is created that implements the MCP specification, as defined in the project structure.
2. The MCP server is configured as a new service (mcp) in the docker-compose.yml file.
3. The MCP server re-uses the application services (e.g., ProjectService, RAGService) to fulfill agent requests.
4. MCP tools are defined for core agent actions: create_project, ingest_document, and query_knowledge.
5. The MCP server is secured using the same JWT authentication logic as the REST API.
6. E2E tests are created to connect to the MCP server (e.g., via a simple client) and execute a basic query_knowledge tool call.

## Tasks / Subtasks

- [ ] Research and Add MCP Dependencies (AC: 1)
  - [ ] Research official MCP Python SDK or specification (e.g., `mcp` package or equivalent)
  - [ ] Add MCP server library to `pyproject.toml` dependencies [Source: architecture/tech-stack.md]
  - [ ] Run `poetry lock` and `poetry install` to update dependencies
  - [ ] Document MCP library version in tech stack if needed

- [ ] Create MCP Server Structure (AC: 1, 3)
  - [ ] Create directory `src/mcp/` [Source: architecture/source-tree.md#mcp]
  - [ ] Create `src/mcp/__init__.py`
  - [ ] Create `src/mcp/server.py` as main MCP server implementation [Source: architecture/source-tree.md#mcp]
  - [ ] Create `src/mcp/context.py` for shared context/dependencies [Source: architecture/source-tree.md#mcp]
  - [ ] Follow Clean Architecture: MCP layer calls Application layer only [Source: architecture/coding-standards.md#critical-rules]
  - [ ] All files must use snake_case naming [Source: architecture/coding-standards.md#naming-conventions]

- [ ] Implement MCP Server Core (AC: 1, 3)
  - [ ] In `src/mcp/server.py`, create MCP server class following MCP specification
  - [ ] Inject application services as dependencies: `ProjectService`, `DocumentService`, `KnowledgeService`, `RAGService` [Source: architecture/source-tree.md#application-layer]
  - [ ] Implement server initialization and configuration loading from `settings.py` [Source: architecture/source-tree.md#shared-config]
  - [ ] Set up async server runtime (MCP typically uses async I/O)
  - [ ] Add comprehensive docstrings and type hints [Source: architecture/coding-standards.md#language-specific-guidelines]
  - [ ] All I/O operations MUST use async/await [Source: architecture/coding-standards.md#language-specific-guidelines]

- [ ] Create MCP Context Management (AC: 3, 5)
  - [ ] In `src/mcp/context.py`, create context manager for shared dependencies
  - [ ] Implement JWT authentication validation for MCP requests (reuse existing JWT logic from Story 1.4) [Source: architecture/security.md#authentication-authorization]
  - [ ] Load database connection, Redis cache, and LLM providers [Source: architecture/source-tree.md#infrastructure-layer]
  - [ ] Ensure stateless design consistent with REST API [Source: architecture/security.md#authentication-authorization]
  - [ ] Follow dependency injection pattern [Source: architecture/coding-standards.md#critical-rules]

- [ ] Define MCP Tools - Create Project (AC: 4)
  - [ ] Create `src/mcp/tools/__init__.py`
  - [ ] Create `src/mcp/tools/projects.py` [Source: architecture/source-tree.md#mcp]
  - [ ] Define MCP tool `create_project` that accepts project parameters (name, description, tags)
  - [ ] Map tool parameters to Application layer DTOs/schemas
  - [ ] Call `ProjectService.create_project()` from Application layer [Source: architecture/source-tree.md#application-layer]
  - [ ] Return project_id and metadata in MCP-compliant format
  - [ ] Handle errors using custom exceptions (e.g., ProjectAlreadyExistsError) [Source: architecture/coding-standards.md#critical-rules]
  - [ ] NO business logic in this layer - only validation and orchestration [Source: architecture/coding-standards.md#critical-rules]

- [ ] Define MCP Tools - Ingest Document (AC: 4)
  - [ ] Create `src/mcp/tools/documents.py` [Source: architecture/source-tree.md#mcp]
  - [ ] Define MCP tool `ingest_document` that accepts project_id, document content, document metadata
  - [ ] Map tool parameters to match Document ingestion use case from Story 2.5
  - [ ] Call `KnowledgeService.ingest_document()` from Application layer [Source: architecture/source-tree.md#application-layer]
  - [ ] Handle file upload/content passing according to MCP protocol
  - [ ] Return document_id and ingestion status in MCP-compliant format
  - [ ] Handle errors gracefully and return appropriate error responses [Source: architecture/error-handling-strategy.md]

- [ ] Define MCP Tools - Query Knowledge (AC: 4)
  - [ ] Create `src/mcp/tools/rag.py` [Source: architecture/source-tree.md#mcp]
  - [ ] Define MCP tool `query_knowledge` that accepts project_id, query_text, optional flags (use_hybrid_search, use_re_ranking, use_agentic_rag)
  - [ ] Map tool parameters to `RAGQueryRequest` schema from Story 3.1-3.3
  - [ ] Call `RAGService.query()` from Application layer [Source: architecture/source-tree.md#application-layer]
  - [ ] Return knowledge items and optional synthesized_answer in MCP-compliant format
  - [ ] Support all RAG features implemented in Stories 3.1-3.3 (hybrid search, re-ranking, agentic RAG)
  - [ ] Handle and log errors appropriately [Source: architecture/error-handling-strategy.md]

- [ ] Configure MCP Server in Docker Compose (AC: 2)
  - [ ] Update `docker-compose.yml` to add new `mcp` service
  - [ ] Configure MCP service to run `src/mcp/server.py`
  - [ ] Set appropriate port mapping (e.g., 8001:8001 or MCP standard port)
  - [ ] Ensure MCP service depends_on: postgres, redis (same as api service)
  - [ ] Share same environment variables (.env file) with api service for consistency
  - [ ] Add volume mounts for code hot-reloading during development
  - [ ] Follow existing docker-compose patterns from api service [Source: docker-compose.yml]

- [ ] Add MCP Server Security (AC: 5)
  - [ ] Implement JWT token validation middleware for MCP server
  - [ ] Reuse `get_current_user` dependency logic from FastAPI (Story 1.4) [Source: architecture/security.md#authentication-authorization]
  - [ ] Require Bearer token in MCP request headers or per MCP auth protocol
  - [ ] Validate token on every MCP tool invocation (stateless) [Source: architecture/security.md#authentication-authorization]
  - [ ] Return appropriate auth errors when token is invalid/missing
  - [ ] NEVER log or expose tokens [Source: architecture/security.md#secrets-management]
  - [ ] Implement RBAC checks if applicable to tool operations [Source: architecture/security.md#authentication-authorization]

- [ ] Create Unit Tests for MCP Tools (AC: 4, 5)
  - [ ] Create `tests/unit/mcp/tools/test_projects.py` [Source: architecture/test-strategy-and-standards.md#unit-tests]
  - [ ] Test `create_project` tool with valid inputs
  - [ ] Test `create_project` with missing/invalid parameters
  - [ ] Create `tests/unit/mcp/tools/test_documents.py`
  - [ ] Test `ingest_document` tool with valid document
  - [ ] Test `ingest_document` with invalid project_id
  - [ ] Create `tests/unit/mcp/tools/test_rag.py`
  - [ ] Test `query_knowledge` tool with all flag combinations
  - [ ] Test `query_knowledge` error handling
  - [ ] Mock all Application layer services (ProjectService, RAGService, etc.) [Source: architecture/test-strategy-and-standards.md#unit-tests]
  - [ ] Mock JWT authentication for tests
  - [ ] Follow AAA pattern (Arrange, Act, Assert) [Source: architecture/test-strategy-and-standards.md#unit-tests]
  - [ ] Target 90%+ coverage for MCP tools [Source: architecture/test-strategy-and-standards.md#coverage-goals]

- [ ] Create Integration Tests for MCP Server (AC: 3)
  - [ ] Create `tests/integration/mcp/test_mcp_server.py` [Source: architecture/test-strategy-and-standards.md#integration-tests]
  - [ ] Test MCP server initialization and startup
  - [ ] Test server can connect to PostgreSQL and Redis
  - [ ] Test server loads Application layer services correctly
  - [ ] Use Testcontainers for PostgreSQL/pgvector and Redis [Source: architecture/test-strategy-and-standards.md#integration-tests]
  - [ ] Verify dependency injection works end-to-end
  - [ ] Test server shutdown and cleanup

- [ ] Create E2E Tests for MCP Server (AC: 6)
  - [ ] Create `tests/e2e/mcp/test_mcp_e2e.py` [Source: architecture/test-strategy-and-standards.md#end-to-end-e2e-tests]
  - [ ] Implement simple MCP client for testing (or use official MCP client library)
  - [ ] Test E2E flow: Connect to MCP server with valid JWT token
  - [ ] Test E2E: Create a project via `create_project` tool
  - [ ] Test E2E: Ingest a document via `ingest_document` tool
  - [ ] Test E2E: Query knowledge via `query_knowledge` tool and verify results
  - [ ] Test authentication: Connect with invalid/missing token and verify rejection
  - [ ] Test error handling: Invalid parameters return proper error messages
  - [ ] Tests create own data and clean up [Source: architecture/test-strategy-and-standards.md#test-data-management]
  - [ ] Run against fully started MCP server (similar to FastAPI E2E tests)

- [ ] Update Documentation (AC: 1, 2)
  - [ ] Update README.md with MCP server usage instructions
  - [ ] Document how to start MCP server via docker-compose
  - [ ] Document MCP tool schemas and parameters
  - [ ] Add examples of connecting to MCP server from AI agents
  - [ ] Update architecture documentation if needed to reflect MCP integration

## Dev Notes

### Previous Story Insights
- Story 3.3 completed Agentic RAG synthesis feature with `use_agentic_rag` flag
- RAG pipeline now supports: vector search (3.1), hybrid search + re-ranking (3.2), and synthesis (3.3)
- All RAG features use async patterns and are configurable via `settings.py`
- JWT authentication is established and working in REST API (from Story 1.4)
- Application layer services are well-structured and ready for reuse

### MCP Protocol Overview
- Model Context Protocol (MCP) is a standard for AI agents to interact with context providers
- MCP servers expose "tools" that agents can invoke programmatically
- MCP uses async I/O and typically runs as a separate service
- MCP requests should include authentication (JWT in our case)
- MCP responses follow a standardized format for tool results and errors
- **IMPORTANT**: Research the official MCP specification and Python SDK during implementation (currently no specific library in dependencies)

### Architecture Alignment
- MCP server sits at the API Layer alongside FastAPI REST API [Source: architecture/components.md#api-layer]
- MCP server MUST NOT contain business logic - only validation and orchestration [Source: architecture/coding-standards.md#critical-rules]
- MCP tools call Application Layer services (ProjectService, RAGService, etc.) [Source: architecture/components.md#application-layer]
- Follow Clean Architecture: api → application → domain/infrastructure [Source: architecture/coding-standards.md#critical-rules]
- Use dependency injection for all services and infrastructure components [Source: architecture/coding-standards.md#critical-rules]

### File Locations (Project Structure)
Based on [Source: architecture/source-tree.md]:
```
src/
├── mcp/
│   ├── __init__.py
│   ├── server.py          # Main MCP server implementation
│   ├── context.py         # Dependency injection context
│   └── tools/
│       ├── __init__.py
│       ├── projects.py    # create_project tool
│       ├── documents.py   # ingest_document tool
│       ├── tasks.py       # (future: task management tools)
│       └── rag.py         # query_knowledge tool
```

### Application Layer Services to Reuse
From [Source: architecture/source-tree.md#application-layer]:
- `src/application/services/project_service.py` - for project management
- `src/application/services/knowledge_service.py` - for document ingestion
- `src/application/services/rag_service.py` - for RAG queries
- These services already implement all business logic needed by MCP tools

### Security Requirements
From [Source: architecture/security.md]:
- **JWT Authentication**: Reuse existing JWT validation from Story 1.4
- **Stateless**: Every MCP request must validate token (no session state)
- **RBAC**: Implement role-based access control for tool invocations
- **No Secrets in Logs**: Never log JWT tokens or API keys
- **Error Messages**: Return appropriate errors without exposing internals

### Docker Configuration
From [Source: docker-compose.yml]:
- Current services: api, postgres, redis
- Add new `mcp` service alongside `api`
- Share same environment variables (.env)
- MCP service should `depends_on: postgres, redis`
- Use separate port from REST API (e.g., 8001)

### Dependencies to Add
Currently in [Source: pyproject.toml]:
- No MCP-specific libraries yet
- Need to research and add official MCP Python SDK (e.g., `mcp` or equivalent)
- May need additional async libraries depending on MCP spec
- All dependencies MUST be added via Poetry to maintain lock file [Source: architecture/tech-stack.md]

## Testing

### Testing Standards
From [Source: architecture/test-strategy-and-standards.md]:

**Unit Tests** (`tests/unit/mcp/`):
- Framework: Pytest
- Pattern: AAA (Arrange, Act, Assert)
- Mocking: Use pytest-mock to mock Application layer services
- Coverage: Target 90%+ for MCP tools
- Scope: Test each tool in isolation with mocked dependencies

**Integration Tests** (`tests/integration/mcp/`):
- Test MCP server with real infrastructure (PostgreSQL, Redis)
- Use Testcontainers for database and cache
- Verify dependency injection and service integration
- Test server lifecycle (startup, shutdown)

**End-to-End Tests** (`tests/e2e/mcp/`):
- Test complete MCP client-server interaction
- Create MCP client (or use official library)
- Test full workflows: create_project → ingest_document → query_knowledge
- Test authentication and error handling
- Run against fully started MCP server
- Tests create and clean up their own data

**Test Data Management**:
- Use pytest fixtures for test dependencies
- All tests run in database transactions (rolled back after test)
- Use factory_boy for creating test domain objects if needed

**Continuous Testing**:
- All tests must pass in CI/CD pipeline (GitHub Actions)
- Run linting (ruff), formatting (black), type checking (mypy)
- Run unit + integration tests on all PRs
- Run E2E tests after deployment to staging

### Key Test Scenarios
1. **Authentication**: Valid token → success, Invalid/missing token → 401 error
2. **create_project tool**: Valid params → project created, Invalid params → validation error
3. **ingest_document tool**: Valid document → ingested successfully, Invalid project_id → not found error
4. **query_knowledge tool**: Valid query → returns results, All RAG flags work correctly
5. **Error Handling**: Network errors, database errors, LLM errors handled gracefully
6. **Concurrent Requests**: MCP server handles multiple simultaneous tool invocations

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-12 | 1.0 | Initial story draft created | Scrum Master (Bob) |

