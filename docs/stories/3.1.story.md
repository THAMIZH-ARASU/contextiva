# Story 3.1: RAG Retrieval API (Core Query)

## Status

**Draft**

## Story

**As a** AI Agent Developer,
**I want** a secured API endpoint to send a text query,
**so that** I can receive the most relevant KnowledgeItems from my project.

## Acceptance Criteria

1. A new endpoint POST `/api/v1/rag/query` is created and secured using the JWT authentication dependency (from Story 1.4).
2. The endpoint accepts a Pydantic schema containing at least project_id and query_text.
3. The incoming query_text is converted to an embedding using the configured Embedding Provider (from Story 2.2).
4. The system performs a vector similarity search (using pgvector) against KnowledgeItems that match the project_id.
5. The search MUST return the top-K (e.g., K=5, configurable via `settings.py`) matching KnowledgeItem chunks.
6. E2E tests are created to ingest a document (using the API from Story 2.5) and then successfully query for its content.

## Tasks / Subtasks

- [ ] Create Pydantic request/response schemas for RAG query (AC: 1, 2)
  - [ ] Create RAGQueryRequest schema in `src/api/v1/schemas/rag.py` (new file) with fields: project_id (UUID), query_text (str, min_length=1), top_k (Optional[int], default=None - will use settings default) [Source: architecture/rest-api-spec.md, architecture/coding-standards.md]
  - [ ] Create RAGQueryResponse schema in same file with fields: results (List[KnowledgeItemResult]), query_id (UUID), total_results (int)
  - [ ] Create nested KnowledgeItemResult schema with fields: id (UUID), chunk_text (str), similarity_score (float), metadata (Optional[Dict]), document_id (UUID)
  - [ ] All schemas MUST use type hints and inherit from Pydantic BaseModel [Source: architecture/coding-standards.md#critical-rules]
  - [ ] Add validation: query_text must be non-empty string with max length 10,000 characters

- [ ] Add RAG configuration to settings (AC: 5)
  - [ ] Update `src/shared/config/settings.py` to add RAG_DEFAULT_TOP_K setting (default: 5) [Source: architecture/source-tree.md#shared-config]
  - [ ] Add RAG_MAX_TOP_K setting (default: 50) to prevent excessive results
  - [ ] Ensure settings are loaded from environment variables with proper defaults [Source: architecture/coding-standards.md#critical-rules]

- [ ] Implement vector similarity search in KnowledgeRepository (AC: 4, 5)
  - [ ] Add async method `vector_search(project_id: UUID, query_embedding: List[float], top_k: int) -> List[KnowledgeItem]` to IKnowledgeRepository interface in `src/shared/domain/models/knowledge.py` [Source: architecture/coding-standards.md#critical-rules]
  - [ ] Implement the method in KnowledgeRepository (`src/shared/infrastructure/database/repositories/knowledge_repository.py`)
  - [ ] Use pgvector's cosine similarity operator (<->) for vector search [Source: architecture/database-schema.md]
  - [ ] Query MUST filter by project_id via JOIN with documents table
  - [ ] Query MUST use the HNSW index created in Story 2.1 for fast similarity search
  - [ ] Return KnowledgeItems ordered by similarity (closest first), limited to top_k
  - [ ] Include similarity score in returned results
  - [ ] Handle edge case: return empty list if no documents exist for project
  - [ ] All database operations MUST use parameterized queries [Source: architecture/coding-standards.md#critical-rules]

- [ ] Create RAG query use case (AC: 3, 4, 5)
  - [ ] Create `src/application/use_cases/knowledge/query_knowledge.py` [Source: architecture/source-tree.md#application-layer]
  - [ ] Create QueryKnowledgeUseCase class with async execute() method
  - [ ] Inject dependencies: KnowledgeRepository (IKnowledgeRepository), EmbeddingService, Settings
  - [ ] Step 1: Validate that project exists (via ProjectRepository) and user has access
  - [ ] Step 2: Use top_k from request or fall back to settings.RAG_DEFAULT_TOP_K, enforce max of settings.RAG_MAX_TOP_K
  - [ ] Step 3: Call EmbeddingService.embed_text(query_text) to get query_embedding [Source: architecture/components.md#infrastructure-layer]
  - [ ] Step 4: Call KnowledgeRepository.vector_search(project_id, query_embedding, top_k)
  - [ ] Step 5: Map KnowledgeItem domain objects to response DTOs with similarity scores
  - [ ] Handle custom exceptions: ProjectNotFoundError, UnauthorizedAccessError [Source: architecture/coding-standards.md#critical-rules]
  - [ ] All methods MUST be async [Source: architecture/coding-standards.md#language-specific-guidelines]

- [ ] Create RAG API endpoint (AC: 1, 2)
  - [ ] Create new router file `src/api/v1/routes/rag.py` [Source: architecture/source-tree.md#api-layer]
  - [ ] Define POST `/api/v1/rag/query` endpoint with JWT authentication dependency (get_current_user from Story 1.4)
  - [ ] Accept RAGQueryRequest schema, validate with Pydantic
  - [ ] Call QueryKnowledgeUseCase.execute() with validated input
  - [ ] Return RAGQueryResponse with 200 OK status
  - [ ] Map custom exceptions to appropriate HTTP responses: ProjectNotFoundError -> 404, UnauthorizedAccessError -> 403, ValidationError -> 422 [Source: architecture/error-handling-strategy.md]
  - [ ] Add endpoint to FastAPI app in `src/api/v1/__init__.py` or `src/api/main.py`
  - [ ] NO business logic in this layer - only validation and orchestration [Source: architecture/coding-standards.md#critical-rules]

- [ ] Create unit tests for RAG use case (AC: 3, 4, 5)
  - [ ] Create `tests/unit/application/use_cases/knowledge/test_query_knowledge.py` [Source: architecture/test-strategy-and-standards.md#unit-tests]
  - [ ] Test successful query execution with valid inputs
  - [ ] Test project not found scenario (ProjectNotFoundError raised)
  - [ ] Test unauthorized access scenario (UnauthorizedAccessError raised)
  - [ ] Test top_k parameter handling: default value, custom value, max enforcement
  - [ ] Test empty results scenario (no documents in project)
  - [ ] Mock all dependencies: KnowledgeRepository, EmbeddingService, ProjectRepository [Source: architecture/test-strategy-and-standards.md#unit-tests]
  - [ ] Follow AAA pattern (Arrange, Act, Assert) [Source: architecture/test-strategy-and-standards.md#unit-tests]
  - [ ] Target 90%+ coverage for use case [Source: architecture/test-strategy-and-standards.md#coverage-goals]

- [ ] Create integration tests for KnowledgeRepository vector search (AC: 4, 5)
  - [ ] Create `tests/integration/infrastructure/database/repositories/test_knowledge_repository_vector_search.py` [Source: architecture/test-strategy-and-standards.md#integration-tests]
  - [ ] Use Testcontainers to spin up real PostgreSQL/pgvector instance [Source: architecture/test-strategy-and-standards.md#integration-tests]
  - [ ] Test vector_search returns correct results ordered by similarity
  - [ ] Test filtering by project_id (only returns items from specified project)
  - [ ] Test top_k limit is enforced
  - [ ] Test empty results for project with no documents
  - [ ] Test similarity scores are returned and ordered correctly
  - [ ] All tests MUST run within transactions that rollback for isolation [Source: architecture/test-strategy-and-standards.md#test-data-management]

- [ ] Create E2E tests for RAG query endpoint (AC: 1, 2, 6)
  - [ ] Create `tests/e2e/api/v1/test_rag.py` [Source: architecture/test-strategy-and-standards.md#end-to-end-e2e-tests]
  - [ ] Test full workflow (AC: 6): POST /api/v1/knowledge/upload to ingest test document, wait for processing, then POST /api/v1/rag/query to retrieve it
  - [ ] Test authentication: request without JWT token returns 401
  - [ ] Test successful query returns 200 with RAGQueryResponse matching schema
  - [ ] Test query with invalid project_id returns 404
  - [ ] Test query with unauthorized project access returns 403
  - [ ] Test query_text validation: empty string returns 422, exceeds max length returns 422
  - [ ] Test top_k parameter: default behavior, custom value, exceeds max returns capped results
  - [ ] Use httpx as test client [Source: architecture/test-strategy-and-standards.md#end-to-end-e2e-tests]
  - [ ] Tests create own data and clean up [Source: architecture/test-strategy-and-standards.md#test-data-management]

## Dev Notes

### Previous Story Insights
From Story 2.6 (Web Crawl Pipeline):
- The ingestion pipeline successfully processes documents asynchronously using FastAPI BackgroundTasks
- KnowledgeItems are stored with embeddings in the knowledge_items table with pgvector support
- The EmbeddingService from Story 2.2 is used via the LLM Provider Factory for generating embeddings
- Document processing follows a consistent pattern: create Document -> extract/chunk text -> embed chunks -> store KnowledgeItems

### Data Models
**KnowledgeItem Entity** [Source: architecture/data-models.md#knowledgeitem]:
- `id`: UUID - Primary key
- `document_id`: UUID - Foreign key to Document (filters by project via JOIN)
- `chunk_text`: str - The raw text of the chunk to be returned in results
- `embedding`: Vector - The pgvector embedding (1536 dimensions for text-embedding-3-small)
- `metadata`: JSON - Additional context (page number, source URL, chunk indices) to return with results
- Relationship: Belongs to ONE Document

**Query Flow** [Source: architecture/core-workflows.md#workflow-2]:
1. Receive query_text from API
2. Convert to embedding via LLM Factory
3. Perform vector similarity search against knowledge_items table
4. Return top-K results with similarity scores

### API Specifications
**Endpoint**: POST `/api/v1/rag/query` [Source: architecture/rest-api-spec.md]:
- Authentication: JWT Bearer token (from Story 1.4)
- Request Body: RAGQueryRequest (project_id, query_text, optional top_k)
- Response: 200 OK with RAGQueryResponse (results array with KnowledgeItemResult objects)
- Error Responses: 401 (Unauthorized), 403 (Forbidden), 404 (Not Found), 422 (Validation Error)

**Security Requirements** [Source: architecture/rest-api-spec.md#security]:
- All endpoints MUST use JWT authentication via bearerAuth security scheme
- Validate user has access to the specified project before executing query

### Component Specifications
**Infrastructure Layer - KnowledgeRepository** [Source: architecture/components.md#infrastructure-layer]:
- Implements IKnowledgeRepository interface from Domain Layer
- Uses asyncpg for PostgreSQL interactions
- Leverages pgvector extension for vector similarity search
- MUST use cosine similarity operator (<->) for vector comparisons

**Application Layer - QueryKnowledgeUseCase** [Source: architecture/components.md#application-layer]:
- Orchestrates the RAG query workflow
- Dependencies: IKnowledgeRepository, EmbeddingService (from LLM Factory), Settings
- NO direct database or external API access - only through repository interfaces and services

**API Layer - RAG Router** [Source: architecture/components.md#api-layer]:
- Zero business logic - only validation and orchestration
- Uses Pydantic schemas for request/response validation
- Maps domain exceptions to HTTP status codes via error handler middleware

### File Locations
Based on Clean Architecture and Source Tree [Source: architecture/source-tree.md]:
- Request/Response Schemas: `src/api/v1/schemas/rag.py` (NEW FILE)
- API Endpoint: `src/api/v1/routes/rag.py` (NEW FILE)
- Use Case: `src/application/use_cases/knowledge/query_knowledge.py` (NEW FILE)
- Repository Interface Update: `src/shared/domain/models/knowledge.py` (ADD METHOD to IKnowledgeRepository)
- Repository Implementation: `src/shared/infrastructure/database/repositories/knowledge_repository.py` (ADD METHOD)
- Settings Update: `src/shared/config/settings.py` (ADD SETTINGS)
- Unit Tests: `tests/unit/application/use_cases/knowledge/test_query_knowledge.py` (NEW FILE)
- Integration Tests: `tests/integration/infrastructure/database/repositories/test_knowledge_repository_vector_search.py` (NEW FILE)
- E2E Tests: `tests/e2e/api/v1/test_rag.py` (NEW FILE)

### Database Schema
**Vector Similarity Search** [Source: architecture/database-schema.md]:
- Table: `knowledge_items`
- Index: HNSW index on `embedding` column using `vector_cosine_ops` (created in Story 2.1)
- Query Pattern:
  ```sql
  SELECT ki.*, ki.embedding <-> $query_vector AS similarity_score
  FROM knowledge_items ki
  JOIN documents d ON ki.document_id = d.id
  WHERE d.project_id = $project_id
  ORDER BY similarity_score ASC
  LIMIT $top_k
  ```
- The `<->` operator calculates cosine distance (lower is more similar)
- HNSW index enables fast approximate nearest neighbor search

### Technical Constraints
**Python & FastAPI Requirements** [Source: architecture/coding-standards.md#language-specific-guidelines]:
- All functions MUST use type hints (mypy compatible)
- All I/O operations MUST be async (async def, await)
- All public functions MUST have Google-style docstrings

**Clean Architecture Enforcement** [Source: architecture/coding-standards.md#critical-rules]:
- API layer MUST NOT import from domain or infrastructure - only calls application layer
- Application layer MUST NOT import from infrastructure - only uses domain interfaces
- Use Repository Pattern - NO direct database access from application/API layers
- Raise custom exceptions from `shared/utils/errors.py` - NEVER generic Exception

**Security** [Source: architecture/error-handling-strategy.md]:
- NO secrets in code - load all config from environment via settings.py
- Use parameterized queries for all database operations (SQL injection protection)
- Validate all user input with Pydantic

**Performance** [Source: PRD NFR5, NFR6]:
- Leverage async/await for non-blocking I/O
- HNSW index provides fast approximate search for vector similarity
- Consider Redis caching for repeated queries (deferred to Story 3.2+ if needed)

## Testing

### Testing Standards
[Source: architecture/test-strategy-and-standards.md]

**Test File Locations**:
- Unit tests: `tests/unit/` mirroring `src/` structure
- Integration tests: `tests/integration/` mirroring infrastructure structure  
- E2E tests: `tests/e2e/api/v1/`

**Testing Framework**: pytest with pytest-mock for mocking

**Coverage Requirements**:
- Application layer (use cases): 90%+
- Infrastructure layer (repositories): 80%+
- Overall story: 85%+

**Test Patterns**:
- Follow AAA (Arrange, Act, Assert) pattern
- Use pytest fixtures for dependencies
- Use factory_boy for test data creation
- All integration tests MUST use Testcontainers for real PostgreSQL/pgvector
- All tests MUST run in transactions that rollback for isolation
- E2E tests create their own data and clean up

**Mocking Strategy**:
- Unit tests: Mock ALL external dependencies (repositories, services)
- Integration tests: Use real database (Testcontainers), stub external APIs (httpx-responses)
- E2E tests: Test against running FastAPI app with real dependencies

**Critical Test Cases**:
- Happy path: successful query with results
- Edge cases: empty results, project not found, unauthorized access
- Validation: invalid inputs (empty query, invalid project_id, excessive top_k)
- Security: authentication required, authorization enforced
- Performance: verify HNSW index is used (check query plan in integration tests)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-09 | 1.0 | Initial story draft created | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent_

### Debug Log References
_To be populated by dev agent_

### Completion Notes List
_To be populated by dev agent_

### File List
_To be populated by dev agent_

## QA Results

_To be populated by QA agent_
