# Story 2.3: Document Management API (CRUD)

## Status

**Draft**

## Story

**As a** AI Agent Developer,
**I want** to perform full CRUD and versioning operations on Documents via the secured REST API,
**so that** I can manage my project's knowledge sources.

## Acceptance Criteria

1. All endpoints are protected by the JWT authentication dependency (from Story 1.4).
2. POST `/api/v1/documents`: Creates a new document (v1.0.0) linked to a project.
3. GET `/api/v1/documents`: Lists all documents for a given project, with pagination.
4. GET `/api/v1/documents/{id}`: Retrieves a specific document (defaults to latest version). Can query for a specific version.
5. PUT `/api/v1/documents/{id}`: Updates the metadata (e.g., name, tags) of a document.
6. DELETE `/api/v1/documents/{id}`: Deletes a document.
7. POST `/api/v1/documents/{id}/version`: Creates a new version of an existing document (e.g., v1.0.1) (FR3).
8. E2E tests are created for all endpoints, verifying functionality, auth, and validation.

## Tasks / Subtasks

- [ ] Create Pydantic request/response schemas (AC: 2-7)
  - [ ] Create DocumentCreate schema in `src/api/v1/schemas/requests.py` with fields: project_id (UUID), name (str), type (DocumentType enum), content_hash (str) [Source: architecture/data-models.md#document]
  - [ ] Create DocumentUpdate schema in `src/api/v1/schemas/requests.py` with optional fields: name (str | None), tags (list[str] | None)
  - [ ] Create DocumentVersionCreate schema in `src/api/v1/schemas/requests.py` with fields: content_hash (str), bump_type (enum: major, minor, patch) [Source: architecture/data-models.md#document]
  - [ ] Create DocumentResponse schema in `src/api/v1/schemas/responses.py` matching Document entity structure [Source: architecture/coding-standards.md]
  - [ ] Create DocumentListResponse schema in `src/api/v1/schemas/responses.py` with fields: documents (list[DocumentResponse]), total (int), skip (int), limit (int)
  - [ ] Add validation: name length, content_hash format (SHA-256), semantic version format [Source: architecture/coding-standards.md]
  - [ ] All schemas MUST use type hints and inherit from Pydantic BaseModel [Source: architecture/coding-standards.md]

- [ ] Implement POST /api/v1/documents endpoint (AC: 2)
  - [ ] Create `create_document` route in `src/api/v1/routes/documents.py` [Source: architecture/source-tree.md#api-layer]
  - [ ] Protect with `Depends(get_current_user)` from Story 1.4 [Source: architecture/security.md#authentication-authorization]
  - [ ] Accept DocumentCreate schema as request body
  - [ ] Call DocumentRepository.create() with Document entity (version set to "v1.0.0") [Source: architecture/data-models.md#document]
  - [ ] Return 201 Created with DocumentResponse [Source: architecture/rest-api-spec.md]
  - [ ] Handle errors: 401 Unauthorized, 404 Project Not Found, 422 Validation Error [Source: architecture/rest-api-spec.md]
  - [ ] Follow Clean Architecture: NO business logic in route, only validation and response formatting [Source: architecture/coding-standards.md#critical-rules]

- [ ] Implement GET /api/v1/documents endpoint (AC: 3)
  - [ ] Create `list_documents` route in `src/api/v1/routes/documents.py`
  - [ ] Protect with `Depends(get_current_user)` [Source: architecture/security.md]
  - [ ] Accept query parameters: project_id (UUID, required), skip (int, default 0), limit (int, default 100, max 1000)
  - [ ] Call DocumentRepository.list_by_project() with pagination [Source: architecture/database-schema.md]
  - [ ] Return 200 OK with DocumentListResponse containing documents array and pagination metadata
  - [ ] Handle errors: 401 Unauthorized, 404 Project Not Found

- [ ] Implement GET /api/v1/documents/{id} endpoint (AC: 4)
  - [ ] Create `get_document` route in `src/api/v1/routes/documents.py`
  - [ ] Protect with `Depends(get_current_user)` [Source: architecture/security.md]
  - [ ] Accept path parameter: id (UUID), optional query parameter: version (str)
  - [ ] If version not specified, call DocumentRepository.get_by_id() to get latest version
  - [ ] If version specified, call DocumentRepository.get_by_version() with document_id and version [Source: architecture/data-models.md#document]
  - [ ] Return 200 OK with DocumentResponse
  - [ ] Handle errors: 401 Unauthorized, 404 Document Not Found

- [ ] Implement PUT /api/v1/documents/{id} endpoint (AC: 5)
  - [ ] Create `update_document` route in `src/api/v1/routes/documents.py`
  - [ ] Protect with `Depends(get_current_user)` [Source: architecture/security.md]
  - [ ] Accept path parameter: id (UUID), request body: DocumentUpdate schema
  - [ ] Retrieve existing document using DocumentRepository.get_by_id()
  - [ ] Update only provided fields (name, tags) - partial update [Source: architecture/rest-api-spec.md]
  - [ ] Call DocumentRepository.update() with modified Document entity
  - [ ] Return 200 OK with updated DocumentResponse
  - [ ] Handle errors: 401 Unauthorized, 404 Document Not Found, 422 Validation Error

- [ ] Implement DELETE /api/v1/documents/{id} endpoint (AC: 6)
  - [ ] Create `delete_document` route in `src/api/v1/routes/documents.py`
  - [ ] Protect with `Depends(get_current_user)` [Source: architecture/security.md]
  - [ ] Accept path parameter: id (UUID)
  - [ ] Call DocumentRepository.delete() with document_id
  - [ ] Return 204 No Content on success [Source: architecture/rest-api-spec.md]
  - [ ] Handle errors: 401 Unauthorized, 404 Document Not Found
  - [ ] Note: CASCADE delete will automatically remove all KnowledgeItems linked to this document [Source: architecture/database-schema.md]

- [ ] Implement POST /api/v1/documents/{id}/version endpoint (AC: 7)
  - [ ] Create `create_document_version` route in `src/api/v1/routes/documents.py`
  - [ ] Protect with `Depends(get_current_user)` [Source: architecture/security.md]
  - [ ] Accept path parameter: id (UUID), request body: DocumentVersionCreate schema
  - [ ] Retrieve existing document using DocumentRepository.get_by_id()
  - [ ] Parse current version (e.g., "v1.2.3") and bump based on bump_type (major/minor/patch) [Source: architecture/data-models.md#document]
  - [ ] Create new Document entity with incremented version and new content_hash
  - [ ] Call DocumentRepository.create() to save new version (same name, project_id, but new version)
  - [ ] Return 201 Created with DocumentResponse containing new version
  - [ ] Handle errors: 401 Unauthorized, 404 Document Not Found, 422 Invalid Version Format

- [ ] Register documents router in FastAPI app (AC: 2-7)
  - [ ] Import documents router in `src/api/main.py` [Source: architecture/source-tree.md]
  - [ ] Register router with prefix "/api/v1" and tag "Documents"
  - [ ] Ensure all routes are accessible at /api/v1/documents/*

- [ ] Add custom exceptions for document operations (AC: 2-7)
  - [ ] Add DocumentNotFoundError to `src/shared/utils/errors.py` [Source: architecture/coding-standards.md#critical-rules]
  - [ ] Add InvalidDocumentVersionError to `src/shared/utils/errors.py`
  - [ ] Add DuplicateDocumentError to `src/shared/utils/errors.py` (for handling duplicate content_hash in same project)
  - [ ] All exceptions MUST inherit from a base ApplicationError or DomainError [Source: architecture/coding-standards.md#critical-rules]

- [ ] E2E tests for POST /api/v1/documents (AC: 8)
  - [ ] Create `tests/e2e/api/v1/test_documents.py` [Source: architecture/test-strategy-and-standards.md#end-to-end-e2e-tests]
  - [ ] Test successful document creation (201 Created, response contains all fields) [Source: architecture/test-strategy-and-standards.md]
  - [ ] Test authentication required (401 Unauthorized without token)
  - [ ] Test validation errors (422 for invalid content_hash, missing fields)
  - [ ] Test project not found (404 when project_id doesn't exist)
  - [ ] Use httpx.AsyncClient to make real HTTP requests to running FastAPI app [Source: architecture/test-strategy-and-standards.md]
  - [ ] Use pytest fixtures for test data cleanup (rollback transaction) [Source: architecture/test-strategy-and-standards.md]

- [ ] E2E tests for GET /api/v1/documents (AC: 8)
  - [ ] Test successful list with pagination (200 OK, correct total count)
  - [ ] Test authentication required (401 Unauthorized)
  - [ ] Test empty list when no documents exist for project
  - [ ] Test pagination: skip and limit parameters work correctly
  - [ ] Test max limit enforcement (limit capped at 1000)

- [ ] E2E tests for GET /api/v1/documents/{id} (AC: 8)
  - [ ] Test successful retrieval of document (200 OK, correct data)
  - [ ] Test authentication required (401 Unauthorized)
  - [ ] Test document not found (404 when id doesn't exist)
  - [ ] Test version query parameter (retrieve specific version)
  - [ ] Test latest version returned when version not specified

- [ ] E2E tests for PUT /api/v1/documents/{id} (AC: 8)
  - [ ] Test successful update of document metadata (200 OK, updated fields)
  - [ ] Test authentication required (401 Unauthorized)
  - [ ] Test document not found (404)
  - [ ] Test partial update (only name changed, tags unchanged)
  - [ ] Test validation errors (422 for invalid name format)

- [ ] E2E tests for DELETE /api/v1/documents/{id} (AC: 8)
  - [ ] Test successful deletion (204 No Content)
  - [ ] Test authentication required (401 Unauthorized)
  - [ ] Test document not found (404)
  - [ ] Test CASCADE delete of KnowledgeItems (verify related knowledge items deleted)

- [ ] E2E tests for POST /api/v1/documents/{id}/version (AC: 8)
  - [ ] Test successful version creation (201 Created, version incremented correctly)
  - [ ] Test major version bump (v1.2.3 → v2.0.0)
  - [ ] Test minor version bump (v1.2.3 → v1.3.0)
  - [ ] Test patch version bump (v1.2.3 → v1.2.4)
  - [ ] Test authentication required (401 Unauthorized)
  - [ ] Test document not found (404)
  - [ ] Test validation errors (422 for invalid content_hash)

## Dev Notes

### Architecture Context

**Clean Architecture Compliance** [Source: architecture/coding-standards.md#critical-rules]:
- API routes in `src/api/v1/routes/documents.py` belong to the API layer
- Routes MUST only validate input, call repository methods, and format responses
- NO business logic in routes (no version calculation, validation, etc. - only orchestration)
- Routes depend on domain interfaces (IDocumentRepository) via dependency injection
- Domain layer (Document entity, IDocumentRepository interface) has NO dependencies on API or infrastructure

**Repository Pattern** [Source: architecture/coding-standards.md#critical-rules]:
- All database access goes through DocumentRepository implementing IDocumentRepository
- Repository already created in Story 2.1 - reuse it
- Repository methods: create(), get_by_id(), get_by_version(), list_by_project(), update(), delete()
- NEVER use asyncpg or SupabaseClient directly from API routes

**Document Versioning** [Source: architecture/data-models.md#document]:
- Semantic versioning: "v1.0.0" format (major.minor.patch)
- Each version is a separate row in the documents table
- Versions share same project_id and name, differ by version and content_hash
- Version bumping logic:
  - major: v1.2.3 → v2.0.0 (breaking changes)
  - minor: v1.2.3 → v1.3.0 (new features)
  - patch: v1.2.3 → v1.2.4 (bug fixes)
- Latest version query: SELECT * FROM documents WHERE id = ? ORDER BY version DESC LIMIT 1

**Authentication & Authorization** [Source: architecture/security.md#authentication-authorization]:
- All endpoints protected with `Depends(get_current_user)` from Story 1.4
- JWT token validated by OAuth2PasswordBearer scheme
- Token passed in Authorization header: "Bearer <token>"
- get_current_user returns User entity, raises 401 if token invalid/expired
- RBAC stub exists but not used in this story (no role-based restrictions)

**Error Handling** [Source: architecture/coding-standards.md#critical-rules]:
- Define custom exceptions in `src/shared/utils/errors.py`:
  - DocumentNotFoundError (404)
  - InvalidDocumentVersionError (422)
  - DuplicateDocumentError (422)
- NEVER raise generic Exception or HTTPException from routes
- Let FastAPI error middleware convert custom exceptions to HTTP responses

**File Structure** [Source: architecture/source-tree.md]:
```
src/api/v1/
├── routes/
│   ├── documents.py (NEW - this story creates it)
│   ├── projects.py (from Story 1.3)
│   └── auth.py (from Story 1.4)
├── schemas/
│   ├── requests.py (add DocumentCreate, DocumentUpdate, DocumentVersionCreate)
│   ├── responses.py (add DocumentResponse, DocumentListResponse)
│   └── common.py
```

### Database Schema

**documents table** [Source: architecture/database-schema.md]:
```sql
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    name TEXT NOT NULL,
    type TEXT NOT NULL,
    version TEXT NOT NULL DEFAULT '1.0.0',
    content_hash TEXT,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);
CREATE INDEX idx_documents_project_id ON documents(project_id);
```

**Important Notes**:
- CASCADE delete: Deleting a document deletes all KnowledgeItems linked to it
- content_hash is SHA-256 (64 hex characters) for deduplication
- type is DocumentType enum: "markdown", "pdf", "docx", "html", "text"
- Migration already created in Story 2.1

### Document Domain Model

**Document Entity** [Source: architecture/data-models.md#document]:
```python
@dataclass(slots=True)
class Document:
    id: UUID
    project_id: UUID
    name: str
    type: DocumentType  # Enum: MARKDOWN, PDF, DOCX, HTML, TEXT
    version: str  # Semantic version: "v1.0.0"
    content_hash: str  # SHA-256 hash
    created_at: datetime
    updated_at: datetime
```

**Validation Rules** (already in Document.__post_init__):
- name cannot be empty
- version must match semantic versioning regex: `^v?\d+\.\d+\.\d+$`
- content_hash must be 64 hex characters (SHA-256)
- type must be valid DocumentType enum value

### IDocumentRepository Interface

**Repository Methods** (already defined in Story 2.1):
```python
class IDocumentRepository(ABC):
    async def create(document: Document) -> Document
    async def get_by_id(document_id: UUID) -> Document | None
    async def get_by_version(document_id: UUID, version: str) -> Document | None
    async def list_by_project(project_id: UUID, skip: int, limit: int) -> list[Document]
    async def update(document: Document) -> Document
    async def delete(document_id: UUID) -> None
```

**Implementation Location**: `src/infrastructure/database/repositories/document_repository.py` (already exists from Story 2.1)

### API Request/Response Schemas

**DocumentCreate** (NEW):
```python
class DocumentCreate(BaseModel):
    project_id: UUID
    name: str = Field(..., min_length=1, max_length=255)
    type: DocumentType
    content_hash: str = Field(..., pattern=r"^[a-fA-F0-9]{64}$")
```

**DocumentUpdate** (NEW):
```python
class DocumentUpdate(BaseModel):
    name: str | None = Field(None, min_length=1, max_length=255)
    tags: list[str] | None = None
```

**DocumentVersionCreate** (NEW):
```python
class DocumentVersionCreate(BaseModel):
    content_hash: str = Field(..., pattern=r"^[a-fA-F0-9]{64}$")
    bump_type: Literal["major", "minor", "patch"]
```

**DocumentResponse** (NEW):
```python
class DocumentResponse(BaseModel):
    id: UUID
    project_id: UUID
    name: str
    type: DocumentType
    version: str
    content_hash: str
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True  # For Pydantic v2 ORM mode
```

**DocumentListResponse** (NEW):
```python
class DocumentListResponse(BaseModel):
    documents: list[DocumentResponse]
    total: int
    skip: int
    limit: int
```

### Version Bumping Logic

**Semantic Versioning Parser**:
```python
import re

def parse_version(version: str) -> tuple[int, int, int]:
    """Parse semantic version string to (major, minor, patch)."""
    match = re.match(r"^v?(\d+)\.(\d+)\.(\d+)$", version)
    if not match:
        raise InvalidDocumentVersionError(f"Invalid version: {version}")
    return int(match.group(1)), int(match.group(2)), int(match.group(3))

def bump_version(current: str, bump_type: str) -> str:
    """Bump version based on type (major, minor, patch)."""
    major, minor, patch = parse_version(current)
    
    if bump_type == "major":
        return f"v{major + 1}.0.0"
    elif bump_type == "minor":
        return f"v{major}.{minor + 1}.0"
    elif bump_type == "patch":
        return f"v{major}.{minor}.{patch + 1}"
    else:
        raise ValueError(f"Invalid bump_type: {bump_type}")
```

**Note**: This logic belongs in a utility module, NOT in the API route

### FastAPI Route Examples

**Route Dependency Injection**:
```python
from fastapi import APIRouter, Depends, HTTPException, status
from src.api.dependencies import get_current_user
from src.domain.models.user import User
from src.domain.models.document import IDocumentRepository, Document
from src.api.dependencies import get_document_repository

router = APIRouter(prefix="/documents", tags=["Documents"])

@router.post("/", status_code=status.HTTP_201_CREATED, response_model=DocumentResponse)
async def create_document(
    data: DocumentCreate,
    current_user: User = Depends(get_current_user),
    doc_repo: IDocumentRepository = Depends(get_document_repository),
) -> DocumentResponse:
    # Implementation here
    pass
```

**Response Models**:
- Use `response_model` parameter to specify Pydantic schema
- FastAPI auto-converts Document entity to DocumentResponse
- Use `status_code` parameter for non-200 responses (e.g., 201 Created, 204 No Content)

### Testing

**E2E Test Structure** [Source: architecture/test-strategy-and-standards.md#end-to-end-e2e-tests]:
```python
import pytest
from httpx import AsyncClient
from src.api.main import app

@pytest.mark.asyncio
async def test_create_document_success(test_client: AsyncClient, auth_token: str):
    """Test successful document creation."""
    # Arrange
    payload = {
        "project_id": "valid-uuid",
        "name": "test.md",
        "type": "markdown",
        "content_hash": "a" * 64
    }
    headers = {"Authorization": f"Bearer {auth_token}"}
    
    # Act
    response = await test_client.post("/api/v1/documents", json=payload, headers=headers)
    
    # Assert
    assert response.status_code == 201
    data = response.json()
    assert data["name"] == "test.md"
    assert data["version"] == "v1.0.0"
```

**Test Fixtures** [Source: architecture/test-strategy-and-standards.md#test-data-management]:
- Use pytest fixtures for httpx.AsyncClient, auth tokens, test database
- Use factory_boy for creating test Document instances
- ALL tests run in transaction, rolled back after test (no data leakage)

**Test Coverage** [Source: architecture/test-strategy-and-standards.md#testing-philosophy]:
- E2E tests: Cover all endpoints (7 endpoints × ~4 scenarios each = ~28 tests)
- Target: 85%+ overall coverage
- Focus: Happy path + error cases (401, 404, 422)

### Previous Story Insights

**From Story 2.1 (Core Domain Models)**:
- ✅ Document entity and IDocumentRepository already exist
- ✅ DocumentRepository implementation already exists
- ✅ Database migration for documents table already created
- ✅ Document validation (version format, content_hash, name) already implemented
- Lesson: Reuse existing domain models and repositories - don't recreate them
- Lesson: Repository methods tested in integration tests - API layer E2E tests will verify end-to-end flow

**From Story 2.2 (LLM Provider Factory)**:
- ✅ Simplified testing approach worked well (focus on initialization, validation, cleanup)
- ✅ Comprehensive docstrings and type hints are crucial
- ✅ Custom exceptions better than generic Exception
- ✅ Singleton pattern prevents duplicate resource initialization
- Lesson: E2E tests should focus on HTTP request/response flow, not repository internals
- Lesson: Use pytest fixtures to set up test data and auth tokens

**From Story 1.4 (Security & Auth)**:
- ✅ JWT authentication via get_current_user dependency
- ✅ OAuth2PasswordBearer scheme for token extraction
- ✅ All protected endpoints use `Depends(get_current_user)`
- ✅ Auth returns 401 Unauthorized for invalid/expired tokens
- Lesson: Always test authentication on ALL endpoints (include 401 test case)
- Lesson: Use test fixtures to generate valid JWT tokens for testing

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-07 | 0.1 | Initial draft created from Epic 2 requirements | Scrum Master (Bob) |

## Dev Agent Record

### Agent Model Used
- (To be filled by Dev Agent)

### Debug Log References
- (To be filled by Dev Agent)

### Completion Notes
- (To be filled by Dev Agent)

### File List
- (To be filled by Dev Agent)

## QA Results

- (To be filled by QA Agent)
